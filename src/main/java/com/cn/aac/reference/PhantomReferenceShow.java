package com.cn.aac.reference;

/**
 * java 4中引用详解
 * 虚引用
 * @author Administrator
 *
 */
public class PhantomReferenceShow {
    /**
     *  “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。
     *  如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
     *  
     *  虚引用主要用来跟踪对象被垃圾回收器回收的活动。
     *  虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。
     *  当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。
     *  
     *  
     *  虚引用（Phantom Reference）的用途较少，主要用于辅助finalize函数的使用。
     *  Phantom对象指一些执行完了finalize函数，并且为不可达对象，但是还没有被GC回收的对象。
     *  这种对象可以辅助finalize进行一些后期的回收工作，我们通过覆盖Reference的clear()方法，增强资源回收机制的灵活性。
     *  虚引用主要适用于以某种比 java 终结机制更灵活的方式调度 pre-mortem 清除操作。
     *  
     *  &注意  
     *      在实际程序设计中一般很少使用弱引用与虚引用，
     *      使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。
     *      
     *  
     *  不可视阶段：
     *      在一个对象经历了应用阶段之后，那么该对象便处于不可视阶段，说明我们在其他区域的代码中已经不可以再引用它，其强引用已经消失，、
     *      例如，本地变量超出了其可视范围，如下所示。
     *      
     *      public void process () { 
     *          try { 
     *              Object obj = new Object(); 
     *              obj.doSomething(); 
     *          } catch (Exception e) { 
     *              e.printStackTrace(); 
     *          } 
     *          
     *          while (isLoop) { // ... loops forever 
     *              // 这个区域对于obj对象来说已经是不可视的了 
     *              // 因此下面的代码在编译时会引发错误 
     *              obj.doSomething();  
     *          } 
     *     } 
     *     
     *     如果一个对象已使用完，而且在其可视区域不再使用，此时应该主动将其设置为空（null）。
     *     可以在上面的代码行obj.doSomething();下添加代码行obj = null;，
     *     这样一行代码强制将obj对象置为空值。这样做的意义是，可以帮助JVM及时地发现这个垃圾对象，并且可以及时地回收该对象所占用的系统资源。
     *     
     *     
     *  不可到达阶段
     *      处于不可到达阶段的对象，在虚拟机所管理的对象引用根集合中再也找不到直接或间接的强引用，
     *      这些对象通常是指所有线程栈中的临时变量，所有已装载的类的静态变量或者对本地代码接口（JNI）的引用。
     *      这些对象都是要被垃圾回收器回收的预备对象，但此时该对象并不能被垃圾回收器直接回收。
     *      其实所有垃圾回收算法所面临的问题是相同的——找出由分配器分配的，但是用户程序不可到达的内存块。
     *      
     *  可收集阶段、终结阶段与释放阶段   
     *      对象生命周期的最后一个阶段是可收集阶段、终结阶段与释放阶段。当对象处于这个阶段的时候，可能处于下面三种情况：
     *          （1）垃圾回收器发现该对象已经不可到达。
     *          （2）finalize方法已经被执行。
     *          （3）对象空间已被重用。
     *      当对象处于上面的三种情况时，该对象就处于可收集阶段、终结阶段与释放阶段了。虚拟机就可以直接将该对象回收了。 
     */
    
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        
    }
    
}
